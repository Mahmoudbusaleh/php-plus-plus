<?php

namespace PHPPlusPlus;

class Router {
    // Stores registered routes organized by HTTP method
    private static $routes = [];

    /**
     * Registers a GET route
     */
    public static function get($path, $callback) {
        self::addRoute('GET', $path, $callback);
    }

    /**
     * Registers a POST route
     */
    public static function post($path, $callback) {
        self::addRoute('POST', $path, $callback);
    }

    /**
     * Registers a one-line redirect
     */
    public static function redirect($from, $to) {
        self::get($from, function() use ($to) {
            header("Location: $to");
            exit;
        });
    }

    /**
     * Converts native path to regex and stores the route
     */
    private static function addRoute($method, $path, $callback) {
        // Convert {param} placeholders to named regex groups
        $pattern = preg_replace('/\{([a-zA-Z0-9_]+)\}/', '(?P<$1>[^/]+)', $path);
        $pattern = "#^" . $pattern . "$#D";
        
        self::$routes[$method][$pattern] = $callback;
    }

    /**
     * Smart Dispatcher: Auto-checks for changes and executes routes
     */
    public static function dispatch() {
        $cacheFile = 'cache/routes_compiled.php';
        $sourceFile = 'index.php';

        // FEATURE: Zero-Config Auto-Build
        // If the cache is missing or index.php was modified, re-compile instantly
        if (!file_exists($cacheFile) || (file_exists($sourceFile) && filemtime($sourceFile) > filemtime($cacheFile))) {
            // Check if Compiler class exists before calling to prevent errors
            if (class_exists(__NAMESPACE__ . '\\Compiler')) {
                Compiler::build();
            }
        }

        $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
        $method = $_SERVER['REQUEST_METHOD'];

        if (!isset(self::$routes[$method])) {
            self::sendNotFound();
            return;
        }

        foreach (self::$routes[$method] as $pattern => $callback) {
            if (preg_match($pattern, $uri, $matches)) {
                $params = array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);
                
                if (is_callable($callback)) {
                    echo call_user_func_array($callback, $params);
                    return;
                }
            }
        }

        self::sendNotFound();
    }

    /**
     * Sends a native 404 response
     */
    private static function sendNotFound() {
        header("HTTP/1.0 404 Not Found");
        echo "404 Not Found - PHP++ Engine";
    }
}
